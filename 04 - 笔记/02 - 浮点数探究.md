### 科学计数法 `E`

大于 `1E16` 时超过有效位，计算无效。

```c++
const int N15 = 1E15 + 1;
const int N16 = 1E16 + 1;
const int Ntt = 1E16 + 123456789;
cout << N15 << endl; // 输出 1000000000000001
cout << N16 << endl; // 输出 10000000000000000
cout << Ntt << endl; // 输出 10000000123456788
```

因为 `E` 本质是浮点数，所以可以用浮点数的知识来解释这一现象，参见下文。

***

### 关于浮点数

1. 某些函数并不支持浮点数传入，例如 `minmax` 函数，翻阅库之后我们可以发现，其只支持传入整数/字符串列表；
2. 某些函数对于浮点数的处理结果可能与我们设想的不同，例如 `numeric_limits::min()` 函数，当我们使用 `numeric_limits<double>::min()` 或 `numeric_limits<long double>::min()` 时会得到 `0.0`；而当我们使用 `numeric_limits<double>::max()` 时则会得到一个长度为 $309$ 位的数字。
3. 如果使用到了浮点数，一定要手动控制小数点后数字的数量（最好是直接写在头文件里以防万一），因为默认的长整型浮点数输出是科学计数法。

<center>
    <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s2.loli.net/2023/10/09/z1GUhjfHrveKaNZ.png" width="65%" /> 
    <div style="border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999;">直接输出是科学计数法的形式</div>
</center>

<center>
    <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s2.loli.net/2023/10/09/Vl4eMu7cambfIT8.png" width="65%" /> 
    <div style="border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999;">https://codeforces.com/blog/entry/69899?#comment-544144</div>
</center>

4. 由于 IEEE 754 规定 `long double` 的精度不少于 `double` 的精度，主流的编程竞赛平台$^{\text{注}}$也确实做到了这一点，故个人习惯使用 `long double` 代替 `double`；但是显然，**更高的精度会导致运行时间变慢**，请谨慎抉择。（$^{\text{注}}$：在现版本的杭电OJ，某些情况下 `long double` 的精度不如 `double`）。

5. 浮点数整数和小数部分共享精度，所以在计算时，整数部分越大，小数部分精度越差。一般我们默认在数据集超过 $10^6$ 时不再使用浮点数进行运算，否则会出现很严重的精度误差。

6. 读入浮点数的速度非常慢，**在大量读入浮点数、需要卡常的情况下**，为了加快读入速度，一般我们默认不直接读入浮点数：对于整数输入，我们一般采取先读入整数后转换成浮点数的方式；对于浮点数输入，我们一般采取先读入字符串后转换成浮点数的方式。当输入量在 $10^5$ 量级时，这样做可以快 $10$ 倍（使用 [例题](https://codeforces.com/contest/257/problem/C) 进行测试）。

7. 读入浮点数会出现精度误差，我时常看到有人在代码中对某一些变量采取诸如 `+= 1E-14` 的调整操作，最终以极短的代码与误差过题（此处 [参考](https://atcoder.jp/contests/abc191/submissions/44365704)，这一份代码对 `r` 变量进行了调整操作，但是经我测试将偏移量修改为 `+= 1E-15` 就无法过题），由于我实在是没能弄明白这究竟是基于数据集采取的卡精度手段还是能被广泛运用的编程技巧，故暂时我也没法给出一个合适的结论。

<center>
    <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s2.loli.net/2023/10/09/2uwfF37vgeISaHE.png" width="65%" /> 
    <div style="border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999;">这个样例中两者的答案输出应当都是 $0.0$ ，但是读入方式的不同最终造成了答案的误差</div>
</center>

<center>
    <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s2.loli.net/2023/10/09/uB2t34ifzHN1cmK.png" width="65%" /> 
    <div style="border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999;">较低的精度模式下不会出现问题，但这其实是四舍五入后的结果，高精度模式下问题会被完全暴露</div>
</center>

5. 由于浮点数四则运算存在严重误差，故一般我们默认不直接对浮点数进行大小比较、也不直接对浮点数进行符号判断。

<center>
    <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s2.loli.net/2023/10/09/Zld8bUcJQBx7DVg.png" width="65%" />
    <div style="border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999;">这个样例中两者的答案输出应当都是 $0.2$ ，但是浮点数的误差导致计算结果并不精确</div>
</center>

<center>
    <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s2.loli.net/2023/10/09/Zpl8v7EC51KGiF3.png" width="65%" />
    <div style="border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999;">浮点数的误差是通病，哪怕是Python也无法直接处理</div>
</center>

<center>
    <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s2.loli.net/2023/10/09/A86WIoBKjSfeYFd.png" width="65%" />
    <div style="border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999;">最终所有这些细小的误差可能导致非常严重的后果</div>
</center>

***

### `pow` 问题

在输出位数超过精度限制后，我们发现即便理论上应该输出整数的结果，但是有时候 `pow` 计算出来的答案并不是一个整数。

<center>
    <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s2.loli.net/2023/10/09/lwthTSHQyqJ26P9.png" width="65%" />
    <div style="border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999;">特定数字会出现问题</div>
</center>

这一现象导致的直接结果就是我们无法利用隐式转换得到开根号之后的值（如下图，$\sqrt[3]{216}$ 的答案应该是 $6$ ，但是由于 `pow` 得到的是 $5$ 开头的小数，隐式转换将小数部分全部舍去，就得到了十分错误的答案）。

<center>
    <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s2.loli.net/2023/10/09/xgR9ePyn6LH8WKt.png" width="65%" />
    <div style="border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999;">误差+隐式转换=重大误差</div>
</center>

> 注：如果需要开立方根，C++库中自带函数 `cbrt` ，用法与 `sqrt` 一致，且两者都保证精确。**以后就不要乱用 `pow` 这种玄学东西了。**

***

### 关于库函数

我们都知道有一些库函数有专门针对浮点数的版本，例如：绝对值函数 `abs` 的浮点数版本 `fabs`、开根号函数 `sqrt` 的浮点数版本 `sqrtf`，但是一般情况下浮点数版本都不如标准版，所以我们一般都只使用标准版本。

<center>
    <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://s2.loli.net/2023/10/09/6NsOMrXAiVy2WtS.png" width="65%" />
    <div style="border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999;">可以看到浮点数版本的精度不如标准版</div>
</center>