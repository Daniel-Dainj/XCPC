## 杂类

### 最长严格/非严格递增子序列 (LIS)

注意子序列是不连续的。使用二分搜索，以 $\mathcal O(N\log N)$ 复杂度通过，另也有 $\mathcal O(N^2)$ 的 $\tt dp$ 解法。

```c++
vector<int> val; // 堆数
for (int i = 1; i <= n; i++) {
    int idx = upper_bound(val.begin(), val.end(), a[i]) - val.begin(); // low/upp: 严格/非严格递增
    if (idx >= val.size()) { // 新增一堆
        val.push_back(a[i]);
    } else {
        val[idx] = a[i]; // 更新堆顶元素数值
    }
}
cout << val.size() << endl;
```

### cout 输出流控制

设置字段宽度：`setw(x)` ，该函数可以使得补全 $x$ 位输出，默认用空格补全。

```c++
bool Solve() {
    cout << 12 << endl;
    cout << setw(12) << 12 << endl;
    return 0;
}
```

![67dce9cb83b4b4ede4f7eb453a7033e0.png](https://s2.loli.net/2023/08/17/LgBUb5vzW2rHEP9.png)

设置填充字符：`setfill(x)` ，该函数可以设定补全类型，注意这里的 $x$ 只能为 $\tt char$ 类型。

```c++
bool Solve() {
    cout << 12 << endl;
    cout << setw(12) << setfill('*') << 12 << endl;
    return 0;
}
```

![761488b7b2fd4871c5cfba7b112fcc6e.png](https://s2.loli.net/2023/08/17/agB6vjfNHwIiQAt.png)

### 读取一行数字，个数未知

```c++
string s;
getline(cin, s);
stringstream ss;
ss << s;
while (ss >> s) {
    auto res = stoi(s);
    cout << res * 100 << endl;
}
```

### 约瑟夫问题

$n$ 个人编号 $0,1,2…,n-1$ ，每次数到 $k$ 出局，求最后剩下的人的编号。

$\mathcal O(N)$ 。

```c++
int jos(int n,int k){
    int res=0;
    repeat(i,1,n+1)res=(res+k)%i;
    return res; // res+1，如果编号从1开始
}
```

$\mathcal O(K\log N)$ ，适用于 $K$ 较小的情况。

```c++
int jos(int n,int k){
    if(n==1 || k==1)return n-1;
    if(k>n)return (jos(n-1,k)+k)%n; // 线性算法
    int res=jos(n-n/k,k)-n%k;
    if(res<0)res+=n; // mod n
    else res+=res/(k-1); // 还原位置
    return res; // res+1，如果编号从1开始
}
```

### 日期换算（基姆拉尔森公式）

已知年月日，求星期数。

```c++
int week(int y,int m,int d){
    if(m<=2)m+=12,y--;
    return (d+2*m+3*(m+1)/5+y+y/4-y/100+y/400)%7+1;
}
```

### 单调队列

查询区间 $k$ 的最大最小值。

```c++
deque<int> D;
int n,k,x,a[MAX];
int main(){
    IOS();
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++){
        while(!D.empty() && a[D.back()]<=a[i]) D.pop_back();
        D.emplace_back(i);
        if(!D.empty()) if(i-D.front()>=k) D.pop_front();
        if(i>=k)cout<<a[D.front()]<<endl;
    }
    return 0;
}
```

### 高精度快速幂

求解 $n^k \bmod p$，其中 $0\le n,k \le 10^{1000000},\ 1\le p \le 10^9$。容易发现 $n$ 可以直接取模，瓶颈在于 $k$ [See](https://codeforces.com/contest/17/problem/D)。

#### 魔改十进制快速幂（暴力计算）

该算法复杂度 $\mathcal O({\tt len}(k))$ 。

```c++
int mypow10(int n, vector<int> k, int p) {
    int r = 1;
    for (int i = k.size() - 1; i >= 0; i--) {
        for (int j = 1; j <= k[i]; j++) {
            r = r * n % p;
        }
        int v = 1;
        for (int j = 0; j <= 9; j++) {
            v = v * n % p;
        }
        n = v;
    }
    return r;
}
signed main() {
    string n_, k_;
    int p;
    cin >> n_ >> k_ >> p;
    
    int n = 0; // 转化并计算 n % p
    for (auto it : n_) {
        n = n * 10 + it - '0';
        n %= p;
    }
    vector<int> k; // 转化 k
    for (auto it : k_) {
        k.push_back(it - '0');
    }
    cout << mypow10(n, k, p) << endl; // 暴力快速幂
}
```

#### 扩展欧拉定理（欧拉降幂公式）

$$n^k \equiv \left\{\begin{matrix}
n^{k \bmod \varphi (p)} & \gcd(n,p)=1 \\ 
n^{k \bmod \varphi(p) + \varphi(p)} & \gcd(n,p)\neq 1 \wedge k\ge\varphi(p)\\ 
n^k & \gcd(n,p)\neq 1 \wedge k<\varphi(p)
\end{matrix}\right.$$

最终我们可以将幂降到 $\varphi(p)$ 的级别，使得能够直接使用快速幂解题，复杂度瓶颈在求解欧拉函数 $\mathcal O(\sqrt p)$ 。

```c++
int phi(int n) { //求解 phi(n)
    int ans = n;
    for (int i = 2; i <= n / i; i++) {
        if (n % i == 0) {
            ans = ans / i * (i - 1);
            while (n % i == 0) {
                n /= i;
            }
        }
    }
    if (n > 1) { //特判 n 为质数的情况
        ans = ans / n * (n - 1);
    }
    return ans;
}
signed main() {
    string n_, k_;
    int p;
    cin >> n_ >> k_ >> p;
    
    int n = 0; // 转化并计算 n % p
    for (auto it : n_) {
        n = n * 10 + it - '0';
        n %= p;
    }
    int mul = phi(p), type = 0, k = 0; // 转化 k
    for (auto it : k_) {
        k = k * 10 + it - '0';
        type |= (k >= mul);
        k %= mul;
    }
    if (type) {
        k += mul;
    }
    cout << mypow(n, k, p) << endl;
}
```

### 快读

注意读入到文件结尾才结束，直接运行会无输出。

```c++
namespace QuickRead { // 快读
    char buf[1 << 21], *p1 = buf, *p2 = buf;
    inline int getc() {
        return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;
    }
    template <typename T> void Cin(T &a) {
        T ans = 0;
        bool f = 0;
        char c = getc();
        for (; c < '0' || c > '9'; c = getc()) {
            if (c == '-') f = 1;
        }
        for (; c >= '0' && c <= '9'; c = getc()) {
            ans = ans * 10 + c - '0';
        }
        a = f ? -ans : ans;
    }
    template <typename T, typename... Args> void Cin(T &a, Args &...args) {
        Cin(a), Cin(args...);
    }
    template <typename T> void write(T x) { // 注意，这里输出不带换行
        if (x < 0) putchar('-'), x = -x;
        if (x > 9) write(x / 10);
        putchar(x % 10 + '0');
    }
} // namespace QuickRead
```

### int128 输入输出流控制

int128 只在基于 $\tt Lumix$ 系统的环境下可用，需要 $\tt C++20$ 。38位精度，除输入输出外与普通数据类型无差别。该封装支持负数读入，需要注意 `write` 函数结尾不输出多余空格与换行。

```c++
namespace my128 { // 读入优化封装，支持__int128
    using i64 = __int128_t;
    i64 abs(const i64 &x) {
        return x > 0 ? x : -x;
    }
    auto &operator>>(istream &it, i64 &j) {
        string val;
        it >> val;
        reverse(val.begin(), val.end());
        i64 ans = 0;
        bool f = 0;
        char c = val.back();
        val.pop_back();
        for (; c < '0' || c > '9'; c = val.back(), val.pop_back()) {
            if (c == '-') {
                f = 1;
            }
        }
        for (; c >= '0' && c <= '9'; c = val.back(), val.pop_back()) {
            ans = ans * 10 + c - '0';
        }
        j = f ? -ans : ans;
        return it;
    }
    auto &operator<<(ostream &os, const i64 &j) {
        string ans;
        function<void(i64)> write = [&](i64 x) {
            if (x < 0) ans += '-', x = -x;
            if (x > 9) write(x / 10);
            ans += x % 10 + '0';
        };
        write(j);
        return os << ans;
    }
} // namespace my128
```

### 对拍版子

- 文件控制

```c++
// Juruo.cpp
freopen("Ask.txt","r",stdin);
freopen("Juruo.out","w",stdout);

// Shenben.cpp
freopen("Ask.txt","r",stdin);
freopen("Shenben.out","w",stdout);

// Ask.cpp
freopen("Ask.txt", "w", stdout);
```

- $\tt{}C++$ 版 $\tt{}bat$

```c++
int main() {
    for (int Case = 1; Case <= 10000; Case++) {
        cout << "==============\n";
        system("Juruo.exe");
        double start = clock();
        system("Shenben.exe");
        double end = clock();
        system("Ask.exe");

        if (system("fc Juruo.out Shenben.out")) {
            puts("WA");
            return 0;
        } else {
            cout << "AC，测试点 #" << Case << "，用时" << end - start << "ms\n";
        }
    }
    return 0;
}
```

### 随机数生成与样例构造

```c++
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
int r(int a, int b) {
    return rnd() % (b - a + 1) + a;
}

void graph(int n, int root = -1, int m = -1) {
    vector<pair<int, int>> t;
    for (int i = 1; i < n; i++) { // 先建立一棵以0为根节点的树
        t.emplace_back(i, r(0, i - 1));
    }

    vector<pair<int, int>> edge;
    set<pair<int, int>> uni;
    if (root == -1) root = r(0, n - 1); // 确定根节点
    for (auto [x, y] : t) { // 偏移建树
        x = (x + root) % n + 1;
        y = (y + root) % n + 1;
        edge.emplace_back(x, y);
        uni.emplace(x, y);
    }

    if (m != -1) { // 如果是图，则在树的基础上继续加边
        for (int i = n; i <= m; i++) {
            while (true) {
                int x = r(1, n), y = r(1, n);
                if (x == y) continue; // 拒绝自环
                if (uni.count({x, y})) continue; // 拒绝重边
                edge.emplace_back(x, y);
                uni.emplace(x, y);
            }
        }
    }

    random_shuffle(edge.begin(), edge.end()); // 打乱节点
    for (auto [x, y] : edge) {
        cout << x << " " << y << endl;
    }
}
```

### 手工哈希

```c++
struct myhash {
    static uint64_t splitmix64(uint64_t x) {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM =
            chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
// unordered_map<int, int, myhash>
```

### Python常用语法

#### 读入与定义

- 读入多个变量并转换类型：`X, Y = map(int, input().split())` 
- 读入列表：`X = eval(input())`
- 多维数组定义：`X = [[0 for j in range(0, 100)] for i in range(0, 200)]`

#### 格式化输出

- 保留小数输出：`print("{:.12f}".format(X))` 指保留 $12$ 位小数
- 对齐与宽度：`print("{:<12f}".format(X))` 指左对齐，保留 $12$ 个宽度

#### 排序

- 倒序排序：使用 `reverse` 实现倒序 `X.sort(reverse=True)` 
- 自定义排序：下方代码实现了先按第一关键字降序、再按第二关键字升序排序。
  ```python
  X.sort(key=lambda x: x[1])
  X.sort(key=lambda x: x[0], reverse=True)
  ```

#### 文件IO

- 打开要读取的文件：`r = open('X.txt', 'r', encoding='utf-8')` 
- 打开要写入的文件：`w = open('Y.txt', 'w', encoding='utf-8')` 
- 按行写入：`w.write(XX)`

#### 自定义结构体

自定义结构体并且自定义排序

```python
class node:
    def __init__(self, A, B, C):
        self.A = A
        self.B = B
        self.C = C

w = []
for i in range(1, 5):
    a, b, c = input().split()
    w.append(node(a, b, c))
w.sort(key=lambda x: x.C, reverse=True)
for i in w:
    print(i.A, i.B, i.C)

```

#### 数据结构

- 模拟于 $\tt C^{map}_{++}$ ，定义：`dic = dict()` 
- 模拟栈与队列：使用常见的 $\tt list$ 即可完成，`list.insert(0, X)` 实现头部插入、`list.pop()` 实现尾部弹出、`list.pop(0)` 实现头部弹出

#### 其他

- 获取ASCII码：`ord()` 函数
- 转换为ASCII字符：`chr()` 函数

### OJ测试

对于一个未知属性的OJ，应当在正式赛前进行以下全部测试：

#### OJ支持语言及编译参数测试

使用 `contains()` 函数测试是否支持 $\tt C++20$ ，使用`__int128` 测试是否是64位编译环境。

```c++
map<int, __int128> dic;
cout << dic.contains(12) << endl;
```

使用 `size()` 函数测试是否是 $\tt Windows$ 系统，如果是，下方代码会输出 $-1$ ；反之，则会返回一个随机数。

```c++
#define int long long
map<int, int> dic;
int x = dic.size() - 1;
cout << x << endl;
```

#### OJ运算速度测试

在循环中调用 `rand()` 函数测试OJ运行速度。

codeforces测试 $2\cdot 10^8$ 次循环结果如下：$\tt C_{++20}^{64bits}$ $1.7s$ ，$\tt C_{++17}^{32bits}$ $1.9s$ 。牛客测试 $2\cdot 10^8$ 次循环结果如下：$\tt C_{++17}^{32bits}$ $1.7s$ 。

```c++
int n = 2e8;
for (int i = 1; i <= n; i++) rand();
```

<div style="page-break-after:always">/END/</div>
